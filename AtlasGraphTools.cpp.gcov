File 'Atlas/AtlasGraphTools.cpp'
Lines executed:100.00% of 90
        -:    0:Source:Atlas/AtlasGraphTools.cpp
        -:    0:Graph:AtlasGraphTools.gcno
        -:    0:Data:AtlasGraphTools.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "AtlasGraphTools.hpp"
        -:    2:
        -:    3:/***********************************************************
        -:    4: ************************************************************
        -:    5: ** Constructor for Node Type without parent graph.
        -:    6: ** Arguments are x and y position of node in cartesian space
        -:    7: ************************************************************
        -:    8: ************************************************************/
        -:    9:
 40000046:   10:Node::Node(float x, float y)
 20000023:   11:{
 20000023:   12:    this->nodeID = -1;
 20000023:   13:    this->location.x = x;
 20000023:   14:    this->location.y = y;
 20000023:   15:    this->neighborCount = 0;
 40000046:   16:}
        -:   17:
        -:   18:
        -:   19:/***********************************************************
        -:   20: ************************************************************
        -:   21: ** Function to add a neighbor to a node
        -:   22: ** A neighbor is defined as a node that
        -:   23: ** can be reached from this node
        -:   24: ** Only Parent Graph will be updated
        -:   25: ** Argument is the node to be added and distance to neightbor
        -:   26: ** Special Return Codes:
        -:   27: **       -1: Indicates Nodes had different parent Graphs
        -:   28: **       -2: Indicated nodes are already neighbors
        -:   29: ************************************************************
        -:   30: ************************************************************/
        -:   31:
       33:   32:int Node::addNeighbor(Node *neighbor)
        -:   33:{
       33:   34:    if (neighbor == (Node *)NULL)
        -:   35:    {
        1:   36:        return NULL_ARG;
        -:   37:    }
        -:   38:
        -:   39:    //
        -:   40:    // Check if the nodes are already neighbors
        -:   41:    //
        -:   42:
        -:   43:    int i;
       77:   44:    for (i = 0; i < this->neighbors.size(); i++) {
       50:   45:        if (this->neighbors[i] == neighbor) {
        5:   46:            return -2;
        -:   47:        }
       45:   48:    }
        -:   49:
        -:   50:    //
        -:   51:    //Calculate the distance between Nodes
        -:   52:    // No need to check return code on distance as
        -:   53:    // this and neighbor are known to be not null
        -:   54:    // At this point
        -:   55:    //
       27:   56:    float distance = getNodeDistance(this, neighbor);
        -:   57:    //
        -:   58:    // Add node and distance to respective vectors
        -:   59:    //
       27:   60:    this->neighbors.insert(this->neighbors.end(), neighbor);
       27:   61:    this->neighborDistances.insert(this->neighborDistances.end(), distance);
       27:   62:    this->neighborCount++;
        -:   63:
       27:   64:    neighbor->neighbors.insert(neighbor->neighbors.end(), this);
       27:   65:    neighbor->neighborDistances.insert(neighbor->neighborDistances.end(), distance);
       27:   66:    neighbor->neighborCount++;
        -:   67:
       27:   68:    return SUCCESS;
        -:   69:
       33:   70:}
        -:   71:
        -:   72:/***********************************************************
        -:   73: ************************************************************
        -:   74: ** Function to get the distance between two nodes
        -:   75: ** Argument is two node pointers
        -:   76: ** inlined to reduce function call overhead
        -:   77: ** Special Return Codes: None
        -:   78: ************************************************************
        -:   79: ************************************************************/
        -:   80:
 10000050:   81:float getNodeDistance(Node *node1, Node *node2)
        -:   82:{
 10000050:   83:    if (node1 == (Node *)NULL || node2 == (Node *)NULL)
        -:   84:    {
        3:   85:        return NULL_ARG;
        -:   86:    }
        -:   87:
 30000141:   88:    return sqrt((node1->getLocation().x - node2->getLocation().x) *
 20000094:   89:                    (node1->getLocation().x - node2->getLocation().x) +
 20000094:   90:                (node1->getLocation().y - node2->getLocation().y) *
 10000047:   91:                    (node1->getLocation().y - node2->getLocation().y));
 10000050:   92:}
        -:   93:
        -:   94:/***********************************************************
        -:   95: ************************************************************
        -:   96: ** Function to check if a node neighbors another node
        -:   97: ** A neighbor is defined as a node that
        -:   98: ** can be reached from this node
        -:   99: ** Argument is potential neighbor
        -:  100: ** Special Return Codes: None
        -:  101: ************************************************************
        -:  102: ************************************************************/
        -:  103:
        7:  104:int Node::isNeighbor(Node *node)
        -:  105:{
        7:  106:    if (node == (Node *)NULL)
        -:  107:    {
        1:  108:        return NULL_ARG;
        -:  109:    }
        -:  110:    int i;
        7:  111:    for (i = 0; i < (int)this->neighbors.size(); i++)
        -:  112:    {
        3:  113:        if (node == this->neighbors[i])
        -:  114:        {
        2:  115:            return 1;
        -:  116:        }
        1:  117:    }
        4:  118:    return 0;
        7:  119:}
        -:  120:
        -:  121:/***********************************************************
        -:  122: ************************************************************
        -:  123: ** Constructor for PriorityQueue Type
        -:  124: ** Arguments is the goal node to be reached in this queue
        -:  125: ************************************************************
        -:  126: ************************************************************/
        -:  127:
        2:  128:PriorityQueue::PriorityQueue(Node *goalNode) {
        1:  129:    this->goalNode = goalNode;
        1:  130:    this->count = 0;
        2:  131:}
        -:  132:
        -:  133:/***********************************************************
        -:  134: ************************************************************
        -:  135: ** Function implementation for GetNodeIndex
        -:  136: ** Takes node to be indexed
        -:  137: ** Returns -1 if the node is not in the queue
        -:  138: ************************************************************
        -:  139: ************************************************************/
        -:  140:
       18:  141:int PriorityQueue::getNodeIndex(Node *node)
        -:  142:{
       18:  143:    if (node == (Node *)NULL) //Check for null input argument
        -:  144:    {
        1:  145:        return NULL_ARG;
        -:  146:    }
        -:  147:
        -:  148:    int i;
        -:  149:
      150:  150:    for (i = 0; i < this->count; i++)
        -:  151:    {
      135:  152:        if (node == this->nodes[i])
        -:  153:        {
        2:  154:            return i;
        -:  155:        }
      133:  156:    }
        -:  157:
       15:  158:    return -1;
       18:  159:}
        -:  160:
        -:  161:/***********************************************************
        -:  162: ************************************************************
        -:  163: ** Function implementation for GetNodeAtIndex
        -:  164: ** Takes the node index
        -:  165: ** No special return codes
        -:  166: ************************************************************
        -:  167: ************************************************************/
        -:  168:
        2:  169:Node* PriorityQueue::getNodeAtIndex(int index) const {
        2:  170:   if(index < this->count)
        1:  171:   return this->nodes[index];
        -:  172:   else {
        1:  173:       return (Node*)OUT_OF_BOUNDS;
        -:  174:   }
        2:  175:}
        -:  176:
        -:  177:/***********************************************************
        -:  178: ************************************************************
        -:  179: ** Function implementation for getHeuristicAtIndex
        -:  180: ** Takes the index
        -:  181: ** No special return codes
        -:  182: ************************************************************
        -:  183: ************************************************************/
        -:  184:
       29:  185:float PriorityQueue::getHeuristicAtIndex(int index) const {
       29:  186:   if(index < this->count)
       28:  187:   return this->heuristics[index];
        -:  188:   else {
        1:  189:       return OUT_OF_BOUNDS;
        -:  190:   }
       29:  191:}
        -:  192:
        -:  193:/***********************************************************
        -:  194: ************************************************************
        -:  195: ** Function implementation for Insert
        -:  196: ** Takes node to be added into queue
        -:  197: ** Returns -2 if the node is already in the queue in a better path
        -:  198: ************************************************************
        -:  199: ************************************************************/
        -:  200:
       18:  201:int PriorityQueue::insert(Node *node, float pathLength)
        -:  202:{
       18:  203:    if (node == (Node *)NULL) //Check for null input argument
        -:  204:    {
        1:  205:        return NULL_ARG;
        -:  206:    }
        -:  207:
        -:  208:    //
        -:  209:    //  Calculate the remaining distance to the goal node
        -:  210:    //
        -:  211:
       17:  212:    float remainingDistance = getNodeDistance(node, this->goalNode);
       17:  213:    float newHeuristic = pathLength + remainingDistance;
        -:  214:
        -:  215:    //
        -:  216:    // Check and see if the node exists in the queue
        -:  217:    //
        -:  218:
       17:  219:    int nodeIndex = this->getNodeIndex(node);
        -:  220:
        -:  221:    //
        -:  222:    // This path is taken if the if the node is in the queue
        -:  223:    //
        -:  224:
       17:  225:    if (nodeIndex != -1)
        -:  226:    {
        2:  227:        if (newHeuristic > this->heuristics[nodeIndex])
        -:  228:        {
        -:  229:            //
        -:  230:            // Node has already been visited with a shorter path. No action necesary.
        -:  231:            //
        -:  232:
        1:  233:            return -2;
        -:  234:        }
        -:  235:        else
        -:  236:        {
        -:  237:
        -:  238:            //
        -:  239:            // Node has already been visited with a longer path. Remove the node and before adding again
        -:  240:            //
        -:  241:
        -:  242:            //this->removeNode(nodeIndex);
        -:  243:        }
        1:  244:    }
        -:  245:
        -:  246:    int index;
       16:  247:    int insertIndex = this->count;
        -:  248:
       16:  249:    this->nodes.resize(this->count+1);
       16:  250:    this->heuristics.resize(this->count+1);
        -:  251:
       76:  252:    for (index = 0; index < this->count; index++)
        -:  253:    {
       74:  254:        if (newHeuristic > heuristics[index])
        -:  255:        {
       14:  256:            insertIndex = index;
       14:  257:            break;
        -:  258:        }
       60:  259:    }
        -:  260:
       76:  261:    for (index = this->count - 1; index >= insertIndex; index--)
        -:  262:    {
       60:  263:        this->nodes[index + 1] = this->nodes[index];
       60:  264:        this->heuristics[index + 1] = this->heuristics[index];
       60:  265:    }
        -:  266:
       16:  267:    this->nodes[insertIndex] = node;
       16:  268:    this->heuristics[insertIndex] = newHeuristic;
       16:  269:    this->count++;
       16:  270:    return SUCCESS;
       18:  271:}
