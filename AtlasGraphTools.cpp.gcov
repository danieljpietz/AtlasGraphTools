        -:    0:Source:Atlas/AtlasGraphTools.cpp
        -:    0:Graph:AtlasGraphTools.gcno
        -:    0:Data:AtlasGraphTools.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "AtlasGraphTools.hpp"
        -:    2:
        -:    3:/***********************************************************
        -:    4: ************************************************************
        -:    5: ** Constructor for Node Type without parent graph.
        -:    6: ** Arguments are x and y position of node in cartesian space
        -:    7: ************************************************************
        -:    8: ************************************************************/
        -:    9:
 40000046:   10:Node::Node(float x, float y)
 20000023:   11:{
 20000023:   12:    this->nodeID = -1;
 20000023:   13:    this->location.x = x;
 20000023:   14:    this->location.y = y;
 20000023:   15:    this->neighborCount = 0;
 20000023:   16:    this->neighbors = new PriorityQueue(this);
 40000046:   17:}
        -:   18:
        -:   19:
        -:   20:/***********************************************************
        -:   21: ************************************************************
        -:   22: ** Function to add a neighbor to a node
        -:   23: ** A neighbor is defined as a node that
        -:   24: ** can be reached from this node
        -:   25: ** Only Parent Graph will be updated
        -:   26: ** Argument is the node to be added and distance to neightbor
        -:   27: ** Special Return Codes:
        -:   28: **       -2: Indicated nodes are already neighbors
        -:   29: ************************************************************
        -:   30: ************************************************************/
        -:   31:
       36:   32:int Node::addNeighbor(Node *neighbor)
        -:   33:{
       36:   34:    if (neighbor == (Node *)NULL)
        -:   35:    {
        1:   36:        return NULL_ARG;
        -:   37:    }
        -:   38:
       35:   39:    if (this->isNeighbor(neighbor)) {
        2:   40:        return -2;
        -:   41:    }
        -:   42:
       33:   43:    int rc1 = this->neighbors->insert(neighbor, 0);
       33:   44:    int rc2 = neighbor->neighbors->insert(this, 0);
        -:   45:
       33:   46:    return (rc1 & rc2);
        -:   47:
       36:   48:}
        -:   49:
        -:   50:/***********************************************************
        -:   51: ************************************************************
        -:   52: ** Function to get the distance between two nodes
        -:   53: ** Argument is two node pointers
        -:   54: ** inlined to reduce function call overhead
        -:   55: ** Special Return Codes: None
        -:   56: ************************************************************
        -:   57: ************************************************************/
        -:   58:
 10000089:   59:float getNodeDistance(Node *node1, Node *node2)
        -:   60:{
 10000089:   61:    if (node1 == (Node *)NULL || node2 == (Node *)NULL)
        -:   62:    {
        3:   63:        return NULL_ARG;
        -:   64:    }
        -:   65:
 30000258:   66:    return sqrt((node1->getLocation().x - node2->getLocation().x) *
 20000172:   67:                    (node1->getLocation().x - node2->getLocation().x) +
 20000172:   68:                (node1->getLocation().y - node2->getLocation().y) *
 10000086:   69:                    (node1->getLocation().y - node2->getLocation().y));
 10000089:   70:}
        -:   71:
        -:   72:/***********************************************************
        -:   73: ************************************************************
        -:   74: ** Function to check if a node neighbors another node
        -:   75: ** A neighbor is defined as a node that
        -:   76: ** can be reached from this node
        -:   77: ** Argument is potential neighbor
        -:   78: ** Special Return Codes: None
        -:   79: ************************************************************
        -:   80: ************************************************************/
        -:   81:
       42:   82:int Node::isNeighbor(Node *node)
        -:   83:{
       42:   84:    if (node == (Node *)NULL)
        -:   85:    {
        1:   86:        return NULL_ARG;
        -:   87:    }
       41:   88:    return (this->neighbors->getNodeIndex(node) != -1);
       42:   89:}
        -:   90:
        -:   91:/***********************************************************
        -:   92: ************************************************************
        -:   93: ** Constructor for PriorityQueue Type
        -:   94: ** Arguments is the goal node to be reached in this queue
        -:   95: ************************************************************
        -:   96: ************************************************************/
        -:   97:
 40000048:   98:PriorityQueue::PriorityQueue(Node *goalNode) {
 20000024:   99:    this->goalNode = goalNode;
 20000024:  100:    this->count = 0;
 40000048:  101:}
        -:  102:
        -:  103:/***********************************************************
        -:  104: ************************************************************
        -:  105: ** Function implementation for GetNodeIndex
        -:  106: ** Takes node to be indexed
        -:  107: ** Returns -1 if the node is not in the queue
        -:  108: ************************************************************
        -:  109: ************************************************************/
        -:  110:
      125:  111:int PriorityQueue::getNodeIndex(Node *node)
        -:  112:{
      125:  113:    if (node == (Node *)NULL) //Check for null input argument
        -:  114:    {
        1:  115:        return NULL_ARG;
        -:  116:    }
        -:  117:
        -:  118:    int i;
        -:  119:
      438:  120:    for (i = 0; i < this->count; i++)
        -:  121:    {
      323:  122:        if (node == this->nodes[i])
        -:  123:        {
        9:  124:            return i;
        -:  125:        }
      314:  126:    }
        -:  127:
      115:  128:    return -1;
      125:  129:}
        -:  130:
        -:  131:/***********************************************************
        -:  132: ************************************************************
        -:  133: ** Function implementation for GetNodeAtIndex
        -:  134: ** Takes the node index
        -:  135: ** No special return codes
        -:  136: ************************************************************
        -:  137: ************************************************************/
        -:  138:
        2:  139:Node* PriorityQueue::getNodeAtIndex(int index) const {
        2:  140:   if(index < this->count)
        1:  141:   return this->nodes[index];
        -:  142:   else {
        1:  143:       return (Node*)OUT_OF_BOUNDS;
        -:  144:   }
        2:  145:}
        -:  146:
        -:  147:/***********************************************************
        -:  148: ************************************************************
        -:  149: ** Function implementation for getHeuristicAtIndex
        -:  150: ** Takes the index
        -:  151: ** No special return codes
        -:  152: ************************************************************
        -:  153: ************************************************************/
        -:  154:
       29:  155:float PriorityQueue::getHeuristicAtIndex(int index) const {
       29:  156:   if(index < this->count)
       28:  157:   return this->heuristics[index];
        -:  158:   else {
        1:  159:       return OUT_OF_BOUNDS;
        -:  160:   }
       29:  161:}
        -:  162:
        -:  163:/***********************************************************
        -:  164: ************************************************************
        -:  165: ** Function implementation for Insert
        -:  166: ** Takes node to be added into queue
        -:  167: ** Returns -2 if the node is already in the queue in a better path
        -:  168: ************************************************************
        -:  169: ************************************************************/
        -:  170:
       84:  171:int PriorityQueue::insert(Node *node, float pathLength)
        -:  172:{
       84:  173:    if (node == (Node *)NULL) //Check for null input argument
        -:  174:    {
        1:  175:        return NULL_ARG;
        -:  176:    }
        -:  177:
        -:  178:    //
        -:  179:    //  Calculate the remaining distance to the goal node
        -:  180:    //
        -:  181:
       83:  182:    float remainingDistance = getNodeDistance(node, this->goalNode);
       83:  183:    float newHeuristic = pathLength + remainingDistance;
        -:  184:
        -:  185:    //
        -:  186:    // Check and see if the node exists in the queue
        -:  187:    //
        -:  188:
       83:  189:    int nodeIndex = this->getNodeIndex(node);
        -:  190:
        -:  191:    //
        -:  192:    // This path is taken if the if the node is in the queue
        -:  193:    //
        -:  194:
       83:  195:    if (nodeIndex != -1)
        -:  196:    {
        5:  197:        if (newHeuristic > this->heuristics[nodeIndex])
        -:  198:        {
        -:  199:            //
        -:  200:            // Node has already been visited with a shorter path. No action necesary.
        -:  201:            //
        -:  202:
        1:  203:            return -2;
        -:  204:        }
        -:  205:        else
        -:  206:        {
        -:  207:
        -:  208:            //
        -:  209:            // Node has already been visited with a longer path. Remove the node and before adding again
        -:  210:            //
        -:  211:
        -:  212:            //this->removeNode(nodeIndex);
        -:  213:        }
        4:  214:    }
        -:  215:
        -:  216:    int index;
       82:  217:    int insertIndex = this->count;
        -:  218:
       82:  219:    this->nodes.resize(this->count+1);
       82:  220:    this->heuristics.resize(this->count+1);
        -:  221:
      195:  222:    for (index = 0; index < this->count; index++)
        -:  223:    {
      156:  224:        if (newHeuristic > heuristics[index])
        -:  225:        {
       43:  226:            insertIndex = index;
       43:  227:            break;
        -:  228:        }
      113:  229:    }
        -:  230:
      213:  231:    for (index = this->count - 1; index >= insertIndex; index--)
        -:  232:    {
      131:  233:        this->nodes[index + 1] = this->nodes[index];
      131:  234:        this->heuristics[index + 1] = this->heuristics[index];
      131:  235:    }
        -:  236:
       82:  237:    this->nodes[insertIndex] = node;
       82:  238:    this->heuristics[insertIndex] = newHeuristic;
       82:  239:    this->count++;
       82:  240:    return SUCCESS;
       84:  241:}
